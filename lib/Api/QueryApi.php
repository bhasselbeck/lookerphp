<?php
/**
 * QueryApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Experimental Looker API 3.1 Preview
 *
 * This API 3.1 is in active development. Breaking changes are likely to occur to some API functions in future Looker releases until API 3.1 is officially launched and upgraded to beta status.  If you have time and interest to experiment with new or modified services exposed in this embryonic API 3.1, we welcome your participation and feedback!  For large development efforts or critical line-of-business projects, we strongly recommend you stick with the API 3.0 while API 3.1 is under construction.
 *
 * OpenAPI spec version: 3.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * QueryApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class QueryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createMergeQuery
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MergeQuery
     */
    public function createMergeQuery($body = null, $fields = null)
    {
        list($response) = $this->createMergeQueryWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation createMergeQueryWithHttpInfo
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MergeQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMergeQueryWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->createMergeQueryRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MergeQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMergeQueryAsync
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMergeQueryAsync($body = null, $fields = null)
    {
        return $this->createMergeQueryAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMergeQueryAsyncWithHttpInfo
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMergeQueryAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->createMergeQueryRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMergeQuery'
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createMergeQueryRequest($body = null, $fields = null)
    {

        $resourcePath = '/merge_queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createQuery
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function createQuery($body = null, $fields = null)
    {
        list($response) = $this->createQueryWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation createQueryWithHttpInfo
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function createQueryWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->createQueryRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createQueryAsync
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryAsync($body = null, $fields = null)
    {
        return $this->createQueryAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createQueryAsyncWithHttpInfo
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->createQueryRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createQuery'
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createQueryRequest($body = null, $fields = null)
    {

        $resourcePath = '/queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createQueryTask
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\QueryTask
     */
    public function createQueryTask($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        list($response) = $this->createQueryTaskWithHttpInfo($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);
        return $response;
    }

    /**
     * Operation createQueryTaskWithHttpInfo
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\QueryTask, HTTP status code, HTTP response headers (array of strings)
     */
    public function createQueryTaskWithHttpInfo($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->createQueryTaskRequest($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\QueryTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createQueryTaskAsync
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryTaskAsync($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        return $this->createQueryTaskAsyncWithHttpInfo($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createQueryTaskAsyncWithHttpInfo
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryTaskAsyncWithHttpInfo($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->createQueryTaskRequest($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createQueryTask'
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createQueryTaskRequest($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createQueryTask'
            );
        }

        $resourcePath = '/query_tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeQuery
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MergeQuery
     */
    public function mergeQuery($merge_query_id, $fields = null)
    {
        list($response) = $this->mergeQueryWithHttpInfo($merge_query_id, $fields);
        return $response;
    }

    /**
     * Operation mergeQueryWithHttpInfo
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MergeQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeQueryWithHttpInfo($merge_query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->mergeQueryRequest($merge_query_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MergeQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeQueryAsync
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeQueryAsync($merge_query_id, $fields = null)
    {
        return $this->mergeQueryAsyncWithHttpInfo($merge_query_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeQueryAsyncWithHttpInfo
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeQueryAsyncWithHttpInfo($merge_query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->mergeQueryRequest($merge_query_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeQuery'
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mergeQueryRequest($merge_query_id, $fields = null)
    {
        // verify the required parameter 'merge_query_id' is set
        if ($merge_query_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merge_query_id when calling mergeQuery'
            );
        }

        $resourcePath = '/merge_queries/{merge_query_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($merge_query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merge_query_id' . '}',
                ObjectSerializer::toPathValue($merge_query_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation query
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function query($query_id, $fields = null)
    {
        list($response) = $this->queryWithHttpInfo($query_id, $fields);
        return $response;
    }

    /**
     * Operation queryWithHttpInfo
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryWithHttpInfo($query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryRequest($query_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryAsync
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryAsync($query_id, $fields = null)
    {
        return $this->queryAsyncWithHttpInfo($query_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryAsyncWithHttpInfo
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryAsyncWithHttpInfo($query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryRequest($query_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'query'
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryRequest($query_id, $fields = null)
    {
        // verify the required parameter 'query_id' is set
        if ($query_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_id when calling query'
            );
        }

        $resourcePath = '/queries/{query_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_id' . '}',
                ObjectSerializer::toPathValue($query_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryForSlug
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function queryForSlug($slug, $fields = null)
    {
        list($response) = $this->queryForSlugWithHttpInfo($slug, $fields);
        return $response;
    }

    /**
     * Operation queryForSlugWithHttpInfo
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryForSlugWithHttpInfo($slug, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryForSlugRequest($slug, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryForSlugAsync
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryForSlugAsync($slug, $fields = null)
    {
        return $this->queryForSlugAsyncWithHttpInfo($slug, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryForSlugAsyncWithHttpInfo
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryForSlugAsyncWithHttpInfo($slug, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryForSlugRequest($slug, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryForSlug'
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryForSlugRequest($slug, $fields = null)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling queryForSlug'
            );
        }

        $resourcePath = '/queries/slug/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTask
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\QueryTask
     */
    public function queryTask($query_task_id, $fields = null)
    {
        list($response) = $this->queryTaskWithHttpInfo($query_task_id, $fields);
        return $response;
    }

    /**
     * Operation queryTaskWithHttpInfo
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\QueryTask, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskWithHttpInfo($query_task_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->queryTaskRequest($query_task_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\QueryTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskAsync
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskAsync($query_task_id, $fields = null)
    {
        return $this->queryTaskAsyncWithHttpInfo($query_task_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskAsyncWithHttpInfo
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskAsyncWithHttpInfo($query_task_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->queryTaskRequest($query_task_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTask'
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskRequest($query_task_id, $fields = null)
    {
        // verify the required parameter 'query_task_id' is set
        if ($query_task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_id when calling queryTask'
            );
        }

        $resourcePath = '/query_tasks/{query_task_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($query_task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_task_id' . '}',
                ObjectSerializer::toPathValue($query_task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTaskMultiResults
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,string]
     */
    public function queryTaskMultiResults($query_task_ids)
    {
        list($response) = $this->queryTaskMultiResultsWithHttpInfo($query_task_ids);
        return $response;
    }

    /**
     * Operation queryTaskMultiResultsWithHttpInfo
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,string], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskMultiResultsWithHttpInfo($query_task_ids)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskMultiResultsRequest($query_task_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskMultiResultsAsync
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskMultiResultsAsync($query_task_ids)
    {
        return $this->queryTaskMultiResultsAsyncWithHttpInfo($query_task_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskMultiResultsAsyncWithHttpInfo
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskMultiResultsAsyncWithHttpInfo($query_task_ids)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskMultiResultsRequest($query_task_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTaskMultiResults'
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskMultiResultsRequest($query_task_ids)
    {
        // verify the required parameter 'query_task_ids' is set
        if ($query_task_ids === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_ids when calling queryTaskMultiResults'
            );
        }

        $resourcePath = '/query_tasks/multi_results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($query_task_ids)) {
            $query_task_ids = ObjectSerializer::serializeCollection($query_task_ids, 'csv', true);
        }
        if ($query_task_ids !== null) {
            $queryParams['query_task_ids'] = ObjectSerializer::toQueryValue($query_task_ids);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTaskResults
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,string]
     */
    public function queryTaskResults($query_task_id)
    {
        list($response) = $this->queryTaskResultsWithHttpInfo($query_task_id);
        return $response;
    }

    /**
     * Operation queryTaskResultsWithHttpInfo
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,string], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskResultsWithHttpInfo($query_task_id)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskResultsRequest($query_task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskResultsAsync
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskResultsAsync($query_task_id)
    {
        return $this->queryTaskResultsAsyncWithHttpInfo($query_task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskResultsAsyncWithHttpInfo
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskResultsAsyncWithHttpInfo($query_task_id)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskResultsRequest($query_task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTaskResults'
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskResultsRequest($query_task_id)
    {
        // verify the required parameter 'query_task_id' is set
        if ($query_task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_id when calling queryTaskResults'
            );
        }

        $resourcePath = '/query_tasks/{query_task_id}/results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($query_task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_task_id' . '}',
                ObjectSerializer::toPathValue($query_task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runInlineQuery
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runInlineQuery($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        list($response) = $this->runInlineQueryWithHttpInfo($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);
        return $response;
    }

    /**
     * Operation runInlineQueryWithHttpInfo
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runInlineQueryWithHttpInfo($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runInlineQueryRequest($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runInlineQueryAsync
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runInlineQueryAsync($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        return $this->runInlineQueryAsyncWithHttpInfo($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runInlineQueryAsyncWithHttpInfo
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runInlineQueryAsyncWithHttpInfo($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runInlineQueryRequest($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runInlineQuery'
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runInlineQueryRequest($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        // verify the required parameter 'result_format' is set
        if ($result_format === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runInlineQuery'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling runInlineQuery'
            );
        }

        $resourcePath = '/queries/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }

        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runQuery
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runQuery($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        list($response) = $this->runQueryWithHttpInfo($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);
        return $response;
    }

    /**
     * Operation runQueryWithHttpInfo
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runQueryWithHttpInfo($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runQueryRequest($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runQueryAsync
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runQueryAsync($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        return $this->runQueryAsyncWithHttpInfo($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runQueryAsyncWithHttpInfo
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runQueryAsyncWithHttpInfo($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runQueryRequest($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runQuery'
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runQueryRequest($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        // verify the required parameter 'query_id' is set
        if ($query_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_id when calling runQuery'
            );
        }
        // verify the required parameter 'result_format' is set
        if ($result_format === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runQuery'
            );
        }

        $resourcePath = '/queries/{query_id}/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }

        // path params
        if ($query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_id' . '}',
                ObjectSerializer::toPathValue($query_id),
                $resourcePath
            );
        }
        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runUrlEncodedQuery
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runUrlEncodedQuery($model_name, $view_name, $result_format)
    {
        list($response) = $this->runUrlEncodedQueryWithHttpInfo($model_name, $view_name, $result_format);
        return $response;
    }

    /**
     * Operation runUrlEncodedQueryWithHttpInfo
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runUrlEncodedQueryWithHttpInfo($model_name, $view_name, $result_format)
    {
        $returnType = 'string';
        $request = $this->runUrlEncodedQueryRequest($model_name, $view_name, $result_format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runUrlEncodedQueryAsync
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runUrlEncodedQueryAsync($model_name, $view_name, $result_format)
    {
        return $this->runUrlEncodedQueryAsyncWithHttpInfo($model_name, $view_name, $result_format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runUrlEncodedQueryAsyncWithHttpInfo
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runUrlEncodedQueryAsyncWithHttpInfo($model_name, $view_name, $result_format)
    {
        $returnType = 'string';
        $request = $this->runUrlEncodedQueryRequest($model_name, $view_name, $result_format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runUrlEncodedQuery'
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runUrlEncodedQueryRequest($model_name, $view_name, $result_format)
    {
        // verify the required parameter 'model_name' is set
        if ($model_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model_name when calling runUrlEncodedQuery'
            );
        }
        // verify the required parameter 'view_name' is set
        if ($view_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $view_name when calling runUrlEncodedQuery'
            );
        }
        // verify the required parameter 'result_format' is set
        if ($result_format === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runUrlEncodedQuery'
            );
        }

        $resourcePath = '/queries/models/{model_name}/views/{view_name}/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($model_name !== null) {
            $resourcePath = str_replace(
                '{' . 'model_name' . '}',
                ObjectSerializer::toPathValue($model_name),
                $resourcePath
            );
        }
        // path params
        if ($view_name !== null) {
            $resourcePath = str_replace(
                '{' . 'view_name' . '}',
                ObjectSerializer::toPathValue($view_name),
                $resourcePath
            );
        }
        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
